{"version":3,"sources":["components/Node.module.css","components/Node.js","components/PathFinder.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","isStart","isEnd","isWalkable","isPath","isVisited","handleClick","x","y","className","styles","node","start","finish","disabled","onMouseOver","e","buttons","console","log","onClick","astar","end","openSet","g","f","heuristic","push","lowestFIndex","i","length","current","reconstruct_path","filter","neighbor","neighbors","tentative_g","previous","find","path","a","b","Math","sqrt","pow","addNeighbors","grid","this","Infinity","h","generateGrid","rows","cols","currentGrid","currentRow","j","generateRandomMaze","gridCopy","map","random","PathFinder","useState","setPath","setGrid","setWall","button","nodes","row","currentNode","key","displayGrid","index","startNode","endNode","foundPath","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d94ec750.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"node\":\"Node_node__2IxtV\",\"start\":\"Node_start__1Gnel\",\"finish\":\"Node_finish__1ku3h\",\"isPath\":\"Node_isPath__9slFb\",\"disabled\":\"Node_disabled__rSpir\"};","import React from 'react'\nimport styles from './Node.module.css'\n\nexport default function Node({isStart, isEnd, isWalkable, isVisited, isPath, handleClick, x, y, ...props}) {\n    return (\n        <div \n        className={`node ${styles.node} ${isStart ? styles.start : null} ${isEnd ? styles.finish : null} ${!isWalkable ? styles.disabled : null} ${isPath ? styles.isPath : null}`}\n        onMouseOver={(e) => {\n            if (e.buttons === 1 || e.buttons === 3) {\n                console.log(e.buttons)\n                handleClick(x, y, e.buttons)\n            }\n        }}\n        onClick={() => handleClick(x, y)}\n        >\n        \n        </div>\n    )\n}\n","import React, { useState } from 'react'\nimport NodeDisplay from './Node'\n\n/**\n * grid is an array of nodes\n * start will be the start node\n * end will be the end node\n * each node will be {x, y, isVisited, hCost, gCost}\n */\nconst astar = (start, end) => {\n    let openSet = []\n\n    start.g = 0;\n    start.f = heuristic(start, end);\n    openSet.push(start)\n\n    while (openSet.length > 0) {\n        let lowestFIndex = 0;\n        for (let i = 0; i < openSet.length; i++) {\n            if (openSet[i].f < openSet[lowestFIndex].f) {\n                lowestFIndex = i;\n            }\n        }\n\n        let current = openSet[lowestFIndex];\n\n        if (current.x === end.x && current.y === end.y) {\n            return reconstruct_path(current)\n        }\n\n        openSet = openSet.filter(node => node.x !== current.x || node.y !== current.y)\n        for (let i = 0; i < current.neighbors.length; i++) {\n            let neighbor = current.neighbors[i]\n\n            if (!neighbor.isWalkable) {\n                continue;\n            }\n\n            let tentative_g = current.g + 1;\n            if (tentative_g < neighbor.g) {\n                neighbor.previous = current;\n                neighbor.g = tentative_g;\n                neighbor.f = neighbor.g + heuristic(neighbor, end)\n\n                if (!openSet.find(node => node.x === neighbor.x && node.y === neighbor.y)) {\n                    openSet.push(neighbor)\n                }\n            }\n        }\n    }\n\n    return []\n}\n\nfunction reconstruct_path(current) {\n    let path = [current]\n\n    while (current.previous) {\n        path.push(current.previous)\n        current = current.previous\n    }\n    \n    return path\n}\n\nfunction heuristic(a, b) {\n    return Math.sqrt(Math.pow((b.x - a.x),2) + Math.pow((b.y-a.y),2))\n}\n\nclass Node {\n    constructor({isWalkable, x, y, isStart, isEnd}) {\n        this.x = x;\n        this.y = y;\n        this.isWalkable = isWalkable\n        this.isStart = isStart;\n        this.isEnd = isEnd;\n        this.f = Infinity;\n        this.g = Infinity;\n        this.h = null;\n        this.neighbors = []\n        this.previous = null;\n    }\n\n    addNeighbors = function(grid) {\n        if (this.x > 0) {\n            this.neighbors.push(grid[this.y][this.x - 1])\n        }\n\n        if (this.x < grid[0].length - 1) {\n            this.neighbors.push(grid[this.y][this.x + 1])\n        }\n\n        if (this.y > 0) {\n            this.neighbors.push(grid[this.y - 1][this.x])\n        }\n\n        if (this.y < grid.length - 1) {\n            this.neighbors.push(grid[this.y + 1][this.x])\n        }\n    }\n}\n\nconst generateGrid = (rows, cols, start, end) => {\n    const currentGrid = []\n    for (let i = 0; i < rows; i++) {\n        const currentRow = []\n        for (let j = 0; j < cols; j++) {\n            let node = new Node({\n                isWalkable: true,\n                x: j,\n                y: i,\n                isStart: start.x === j && start.y === i,\n                isEnd: end.x === j && end.y === i,\n            });\n\n            if (node.isStart || node.isEnd) {\n                node.isWalkable = true;\n            }\n            currentRow.push(node)\n        }\n        currentGrid.push(currentRow)\n    }\n\n    for (let i = 0; i < rows ; i++) {\n        for (let j = 0; j < cols; j++) {\n            currentGrid[i][j].addNeighbors(currentGrid);\n        }\n    }\n\n    return currentGrid\n}\n\nconst generateRandomMaze = (grid) => {\n    const gridCopy = [...grid.map(g => [...g])]\n\n    for (let i = 0; i < gridCopy.length; i++) {\n        for (let j = 0; j < gridCopy.length; j++) {\n            gridCopy[i][j].isWalkable = Math.random() < 0.2 ? false : true;\n        }\n    }\n\n    return gridCopy;\n}\n\nexport default function PathFinder() {\n    const [rows, setRows] = useState(50)\n    const [cols, setCols] = useState(50)\n\n    const [start, setStart] = useState({x: 0, y: 0})\n    const [end, setEnd] = useState({x: rows - 1, y: cols - 1})\n    const [path, setPath] = useState([])\n\n    const [grid, setGrid] = useState(generateGrid(rows, cols, start, end));\n    \n\n    const setWall = (x, y, button) => {\n        const gridCopy = [...grid.map(g => [...g])]\n        if (button === 1) {\n            gridCopy[y][x].isWalkable = false;\n        } else {\n            gridCopy[y][x].isWalkable = true;\n        }\n        setGrid(gridCopy);\n    }\n\n    const displayGrid = (grid) => {\n        const nodes = []\n        for (let i=0; i< grid.length; i ++) {\n            const row = []\n            for (let j=0; j< grid[i].length; j++) {\n                const currentNode = grid[j][i];\n                if (path && path.find(node => node.x === currentNode.x && node.y === currentNode.y)) {\n                    row.push(<NodeDisplay key={`row-${i} col-${j}`} {...currentNode} isPath handleClick={setWall}/>)\n                } else {\n                    row.push(<NodeDisplay key={`row-${i} col-${j}`} {...currentNode} handleClick={setWall}/>)\n                }\n            }\n\n            nodes.push(row)\n        }\n\n        return nodes \n    }\n\n    const searchPath = () => {\n        const gridCopy = [...grid.map(g => [...g])]\n\n        for (let i = 0; i < grid.length; i++) {\n            for (let j = 0; j < grid[i].length; j++) {\n                let currentNode = gridCopy[i][j]\n                currentNode.f = Infinity;\n                currentNode.g = Infinity;\n                currentNode.h = null;\n            }\n        }\n        setGrid(gridCopy)\n\n        const startNode = grid[start.x][start.y]\n        const endNode = grid[end.x][end.y]\n\n        const foundPath = astar(startNode, endNode)\n\n        if (foundPath.length > 0) {\n            setPath(foundPath);\n        } else {\n            setPath(null)\n        }\n    }\n\n    const reset = () => {\n        setPath([])\n        setGrid(generateGrid(rows, cols, start, end))\n    }\n\n    const generateMaze = () => {\n        setPath([])\n        setGrid(generateRandomMaze(grid, 0))\n    }\n\n    return (\n        <div>\n            <div className=\"grid\">\n                {!path ? 'No path' : null}\n                {displayGrid(grid).map((row, index) => <div className=\"row\" key={index}>{row}</div>)}\n                <button onClick={searchPath}>Search</button>\n                <button onClick={reset}>Reset</button>\n                <button onClick={generateMaze}>Generate Maze</button>\n            </div>\n        </div>\n    )\n}\n","import React from 'react';\nimport PathFinder from './components/PathFinder'\nimport './App.css'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFinder />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}